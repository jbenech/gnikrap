== Script API

// ///////////////////////////////////////////////////////////////////////////
=== General principles
// ///////////////////////////////////////////////////////////////////////////

The API has been designed to be simple to use. Here are some explanation that will help you to use
the API in a more efficient way:

* Single entry point: All the API can be accessed from the a single object: `ev3` (see <<The ev3 object>> for more details).
** All the stuff physically linked to the EV3 brick can be accessed from the object: `ev3.getBrick()` (see <<The Brick object>> for more details).
* Method naming convention (don't be afraid, there is nothing exotic here) : 
** All the methods names starts with an verb.
** All the methods starting by `is` always returns a boolean (i.e. `true` or `false`).
** All the methods starting with `get` are 'getters' and will return a value.
** All the methods starting with `set` are 'setters' and will set a value.
** The API is English based.
* All the times are expressed in milliseconds (1 second is equals to 1000 milliseconds).
* All the angles are expressed in degrees (in general negative and positive degrees are accepted).



// ///////////////////////////////////////////////////////////////////////////
=== The ev3 object
// ///////////////////////////////////////////////////////////////////////////

[TIP]
====
This object is the entry point of the Gnikrap API. In other word, you can access to all the Gnikrap feature from this object.
====

****
isOk():: Enable to known is everything is ok and the script can continue running not. Returns `true` if the script can continue running, `false` if the script should stop.

getBrick():: Returns <<The Brick object>>.

notify(text):: Display a message on the Gnikrap interface. +
               *text*: the text of the message to display.

sleep(timeInMs):: Make the script sleeping for the given number of milliseconds. +
                  *timeInMs*: the sleeping time (in milliseconds).

getConfiguration():: Returns a <<Configuration object>>. Enable to configure some behaviour of the scripting environment.

getXSensor(XSensorName):: Returns <<The XSensor object>> for the XSensor with the given name. (The name is configured within the GUI)
                         *XSensorName*: the name of the sensor.
****


==== Configuration object

[WARNING]
====
Configuration object is for advanced usage only. If you don't understand what it means, don't use this object.
====

****
setIsOkCheckEscapeKey(checkEscapeKey)::  Enable the check of the kbd:[Escape] Mindstrom brick key when
                                         `isOk()` is called. *Default is `true`*. +
                                         *checkEscapeKey*: if `true` check the kbd:[Escape] key, if `false` don't check nothing.

isIsOkCheckEscapeKey():: Returns `true` if kbd:[Escape] key check on `isOk()` is enabled, `false` otherwise (don't check).

setIsOkWait(timeInMs):: Set the time to wait when `isOk()` is called. *Default is `0` (no waiting time)*. +
                        *timeInMs*: the time to wait, `0` means no wait.

getIsOkWait():: Returns the time to wait when `isOk()` is called.

setWaitingTimeBeforeHardKill(timeInMs)::  Set a maximum time to wait before hard killing the script (eg. infinite loop).
                                          *Default is 5000 (5 seconds)*. +
                                          *timeInMs*: the time to wait before hard killing the script. Valid values between 500 and 30000.

getWaitingTimeBeforeHardKill()::  Returns the time to wait before hard killing the script.
****


// ///////////////////////////////////////////////////////////////////////////
=== The Brick object
// ///////////////////////////////////////////////////////////////////////////

[[img-ev3-brick]]
.45500 Intelligent Brick - image from http://education.lego.com
image::ev3/Brick.png[EV3 Brick, 300, 200]


[TIP]
====
This object is the entry point for all the stuff that is connected to the brick. That is to say, that if you want to access to the brick or something connected to the brick, this object will be the good starting point.
====


****
getMediumMotor(port):: Return a <<The Motor object,medium Motor>> object for the given port. +
                       *port*: value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getLargeMotor(port):: Return a <<The Motor object,large Motor>> object for the given port. +
                      *port*: value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getColorSensor(port):: Return a <<The Color sensor object,Color sensor object>> for the given port. +
                       *port*: value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getIRSensor(port):: Return an <<The IR (Infra-Red) sensor object,Infra-Red sensor>> object for the given port. +
                    *port*: value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getTouchSensor(port):: Return a <<The Touch sensor object,Touch sensor>> object for the given port. +
                       *port*: value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getKeyboard():: Return <<The Keyboard object, Keyboard object>>.

getLed():: Return the <<The Led object,Led object>>.

getSound():: Return the <<The Sound object,Sound object>>.

getScreen():: Return the <<The Screen object,Screen object>>.

getBattery():: Return the <<The Battery object,Battery object>>.
****

See the others objects in order to have sample usage of the brick object.


// ///////////////////////////////////////////////////////////////////////////
=== The Motor object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/MotorMedium.png[Medium motor, 300, 200, float="right"]
[[img-ev3-motors]]
.45502 Large Servo Motor / 45503 Medium Servo Motor - images from http://education.lego.com
image::ev3/MotorLarge.png[Large motor, 300, 200, align="left"]

[TIP]
====
On the motor API, some call wait that the operation is ended on the motor (so when the
function returns the motor has ended the expected move) while other immediately returns (so
the motor is still operating/moving while the function returns). The behaviour is specified for each function.
====

****
forward():: Motor rotate forward until `stop()`. This call immediately return.

backward():: Motor rotate backward until `stop()`. This call immediately return.

stop():: Stop and lock the motor. This call immediately return.

stop(lock):: Stop and lock or not the motor. This call immediately return. +
             *lock*: is the motor locked ? Value should be in [`true`, `false`]

stop(lock, immediateReturn):: Stop and lock or not the motor. +
                              *lock*: should be in [`true`, `false`] +
                              *immediateReturn*: Is the function returns immediately or wait that the motor was locked ?
                              Values should be in [`true`, `false`]

rotate(angle):: Rotate the given number of degree. This call wait the end of the motor move. +
                *angle*: the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.

rotate(angle, immediateReturn):: Rotate the given number of degree. This call wait the end of the motor move. +
                                 *angle*: the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.
                                 *immediateReturn*: Is the function returns immediately or wait that the motor rotation was ended ?
                                 Values should be in [`true`, `false`]

isMoving():: Returns `true` if the motors is currently moving, `false` otherwise.

getTachoCount():: Returns the tacho count in degree of the motor (_i.e._ the degree rotated since the last `resetTachoCount`).

resetTachoCount():: Reset the tacho count to `0`.

setSpeedPercent(percent):: Set the speed in percent of the maximum speed. +
                           *percent*: the speed in percent of the maximum speed, 100 is full speed, 1 is minimum speed. +
                           100% is currently set to 720° per second (120 rotation per minute) for the large motor and 1080° per second 
                           (180 rotation per minute) for the medium motor.

getSpeedPercent():: Get the speed in percent of the maximum speed.

setSpeed(degreePerSecond):: Set the speed in degrees per second. +
                            *degreePerSecond*: the number of degrees per second that the motor should target ; one motor rotation is 360 degrees. +
                             According to the LEGO documentation, the maximum sustainable speed is 960° per second for the large motor (i.e. 160 rotation per minute as claimed in the documentation)
                             and 1440° per second for the medium motor (i.e. 240 rotation per minute as claimed in the documentation).

getSpeed():: Get the speed in degrees per second.
****

Sample code for the Motor object:

[source,javascript]
----
var largeMotor = ev3.getBrick().getLargeMotor("B");

// Rotate and wait end of rotation
largeMotor.rotate(360);
largeMotor.setSpeedPercent(100);
largeMotor.rotate(-360);

// Retrieve tacho
largeMotor.rotate(60);
ev3.notify("TachoA: " + largeMotor.getTachoCount());
largeMotor.rotate(-60);
ev3.notify("TachoB: " + largeMotor.getTachoCount());
largeMotor.resetTachoCount();
ev3.notify("TachoC: " + largeMotor.getTachoCount());

// Rotate and don't wait
var tacho;
largeMotor.rotate(360 * 3, true);
while((tacho = largeMotor.getTachoCount()) < 1000) {
  ev3.notify("Tacho: " + tacho);
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Color sensor object
// ///////////////////////////////////////////////////////////////////////////

[[img-ev3-color-sensor]]
.45506 Color Sensor - image from http://education.lego.com
image::ev3/ColorSensor.png[Color sensor, 300, 200]


****
getReflectedLight():: Returns the reflected light: a value between 0 and 100.

getAmbientLight():: Returns the ambient light: a value between 0 and 100.

getColor():: Returns a <<Color object>>.
****


[WARNING]
====
This sensor has 3 different modes. It is worth noting that *switching from one mode to the other take time* (around 250ms).

Here is two examples:

* If you call `getReflectedLight()` and latter call it again (and again) there is no switch and the call to `getReflectedLight()` is instantaneous.
* If you call `getReflectedLight()`  and latter call `getColor()` there is mode switch and the call to `getColor()` will take more than 250ms. 
After this 1^st^ call, successive calls to `getColor()`  will be instantaneous.
====


==== Color object

****
getValue():: Returns the color values as a number.

isNoColor():: Returns `true` if no color was detected, `false` otherwise.

isBlack():: Returns `true` if the black color was detected, `false` otherwise.

isBlue():: Returns `true` if the blue color was detected, `false` otherwise.

isYellow():: Returns `true` if the yellow color was detected, `false` otherwise.

isRed():: Returns `true` if the red color was detected, `false` otherwise

isWhite():: Returns `true` if the white color was detected, `false` otherwise.

isBrown():: Returns `true` if the brown color was detected, `false` otherwise.

getColorAsText:: Returns the color as a string.
****


Sample code for the color sensor:
[source,javascript]
.Reflected light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Reflected light: " + colorSensor.getReflectedLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Ambient light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Ambient light: " + colorSensor.getAmbientLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Color API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Color: " + colorSensor.getColor());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The IR (Infra-Red) sensor object
// ///////////////////////////////////////////////////////////////////////////

[[img-ev3-ir-sensor]]
.45509 IR Sensor - image from http://education.lego.com
image::ev3/IRSensor.png[IR sensor, 300, 200]

****
setChannel(channel):: Set the channel to use with the IR sensor. +
                      *channel*: the channel number, value should be in [1, 2, 3, 4].

getChannel():: Return the channel currently used.

getDistance():: Returns the distance for the IR sensor to something in cm, the value is from 0 to 100cm.

getRemoteCommand():: Check for remote command (beacon) buttons usage. Returns a <<RemoteCommandResult object>>.

seekBeacon():: Look for the beacon and returns a <<SeekBeaconResult object>>.
****

[WARNING]
====
This sensor has 3 different modes. It is worth noting that *switching from one mode to the other take time* (around 250ms).

Here is two examples:

* If you want to monitor the remote command, you will call `getRemoteCommand()` and latter it again (and again) there is no switch and the call to `getRemoteCommand()` is instantaneous.
* If you want to both monitor the remote command and check the distance, you will call `getRemoteCommand()`  and latter call `getDistance()`. In this case there is a mode switch and the call to `getDistance()` will take more than 250ms. If latter you want to call `getRemoteCommand()` there is again a mode switch.
====


==== RemoteCommandResult object

[[img-ev3-ir-beacon]]
.45508 IR Beacon - image from http://education.lego.com
image::ev3/IRBeacon.png[IR Beacon, 300, 200]

****
getValue():: Returns integer value of the remote beacon.

isTopLeftEnabled():: Returns `true` if the top left button was pressed, `false` otherwise.

isTopRightEnabled():: Returns `true` if the top right button was pressed, `false` otherwise.

isBottomLeftEnabled():: Returns `true` if the bottom left button was pressed, `false` otherwise.

isBottomRightEnabled():: Returns `true` if the bottom right button was pressed, `false` otherwise.

isBeaconEnabled():: Returns `true` if beacon mode was enabled, `false` otherwise.

isNothingEnabled():: Returns `true` nothing was enabled, `false` otherwise.
****

==== SeekBeaconResult object

****
isBeaconFound():: Returns `true` if the beacon was detected, `false` otherwise.

getBearing():: Returns the beacon bearing value from -12 to 12 (with values increasing clockwise when looking from behind the sensor.
               A bearing of 0 indicates the beacon is directly in front of the sensor).

getDistance():: Returns beacon distance in cm from 0 to 100cm. If the beacon is not found, 128 was returned.

isBeaconFound(channel):: Same as `isBeaconFound()` on the given channel.

getBearing(channel):: Same as `getBearing()` on the given channel.

getDistance(channel):: Same as `getDistance()` on the given channel.
****


Sample code for the IR sensor object:

[source,javascript]
.Distance API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Distance: " + irSensor.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Seek beacon API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.seekBeacon();
  ev3.notify("Beacon found: " + x.isBeaconFound() + ", bearing: " + x.getBearing() + ", distance: " + x.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Remote command API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.getRemoteCommand();
  ev3.notify("value: " + x.getValue() + 
            ", tl: " + x.isTopLeftEnabled() + ", tr: " + x.isTopRightEnabled() + 
            ", bl: " + x.isBottomLeftEnabled() + ", br: " + x.isBottomRightEnabled() + 
            ", bea: " + x.isBeaconEnabled() + " nothing: " + x.isNothingEnabled());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Touch sensor object
// ///////////////////////////////////////////////////////////////////////////

[[img-ev3-touch-sensor]]
.45507 Touch Sensor - image from http://education.lego.com
image::ev3/TouchSensor.png[Touch sensor, 300, 200]

****
isPushed():: Returns `true` if the sensor was pushed, `false` otherwise.
****

Sample code for the Touch sensor object
[source,javascript]
----
// Touch sensor API
var touchSensor = ev3.getBrick().getTouchSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Push button: " + touchSensor.isPushed());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Keyboard object
// ///////////////////////////////////////////////////////////////////////////

****
getDown():: Returns a <<Button object>> for the kbd:[Down] button.

getEnter():: Returns a <<Button object>> for the kbd:[Enter] button.

getEscape():: Returns a <<Button object>> for the kbd:[Escape] button. +
              _Note:_ The kbd:[Escape] button can also be checked by the `isOk()` function.

getLeft():: Returns a <<Button object>> for the kbd:[Left] button.

getRight():: Returns a <<Button object>> for the kbd:[Right] button.

getUp():: Returns a <<Button object>> for the kbd:[Up] button.

waitForAnyPress():: Wait for some button to be pressed. Returns the id of the button that has been pressed.

getLed():: Returns a <<The Led object,Led object>>. The Led object enable to pilot the LED integrated to the Mindstorm brick keyboard.
****


==== Button object

****
isUp():: Returns `true` if the button is up, `false` otherwise.

isDown():: Returns `true` if the button is down, `false` otherwise.

waitForPress():: Wait until the button has been pressed.

waitForPressAndRelease():: Wait until the button has been pressed and released.

getId():: Returns the id (number) of the button.
****


Sample code for the Keyboard object:
[source,javascript]
----
// Keyboard API
var enterKey = ev3.getBrick().getKeyboard().getEnter();
ev3.notify("Press enter to continue");
while(enterKey.isUp() && ev3.isOk()) {
  ev3.sleep(200);
}
ev3.notify("Enter - Down: " + enterKey.isDown() + " / Up: " + enterKey.isUp());
----


// ///////////////////////////////////////////////////////////////////////////
=== The Led object
// ///////////////////////////////////////////////////////////////////////////

****
off():: Disable the LED.

lightGreen():: Enable the green LED.

lightRed():: Enable the red LED.

lightOrange():: Enable the orange LED.

blink():: Set the LED blinking. Note calling once blink set the 1st mode, calling twice, set the 2nd mode and calling 3 time don't blink anymore.
****


Sample code for the Led object:
[source,javascript]
----
// Led API
var leds = ev3.getBrick().getLed();
leds.lightGreen();
ev3.sleep(2000);
leds.lightOrange().blink();
ev3.sleep(2000);
leds.lightRed().blink().blink();
ev3.sleep(2000);
leds.off();
----


// ///////////////////////////////////////////////////////////////////////////
=== The Sound object
// ///////////////////////////////////////////////////////////////////////////

****
setVolume(vol):: Set the sound volume. +
                 *vol*: the volume, valid values are between 0 and 100.

getVolume():: Returns the sound volume.

beep():: Play a beep.

playTone(frequency, durationInMs):: Play a tone of the given frequency for the given duration. +
                                    *frequency*: the frequency of the tone in Hertz (Hz). Note: In order to be audible, use values between 50 and 2000. +
                                    *durationInMs*: the duration in milliseconds.

playNote(note, durationInMs):: Play the given note for the given duration. +
                               *note*: the note to play. Notes should be in ["C1"-"B7", # allowed on C, D, F, G, A] or ["Do"-"Si", # allowed on Do, Re, Fa, Sol, La]. +
                               *durationInMs*: the duration in milliseconds.
****


Sample script with Sound object:
[source,javascript]
----
// Sound API
var sound = ev3.getBrick().getSound();
sound.setVolume(90);
sound.beep();
for(freq = 50; freq < 1500; freq = freq + 10) {
  sound.playTone(freq, 5);
}
sound.playNote("Do", 500);
sound.playNote("Re", 500);
sound.playNote("Mi", 500);
sound.playNote("Fa", 500);
sound.playNote("Sol", 500);
sound.playNote("La", 500);
sound.playNote("Si", 500);
----


// ///////////////////////////////////////////////////////////////////////////
=== The Screen object
// ///////////////////////////////////////////////////////////////////////////

The EV3 screen is monochrome (only white and black) and has a resolution of 178x128.

image::ev3_screen_resolution.png[EV3 screen]


****
clear():: Clear the LCD screen.

drawText(txt, x, y):: Draw some text at the given x and y position. +
                      *txt*: the text to draw. If a number or something else is given, it will be converted in text before drawing. +
                      *x*, *y*: the x coordinate of the top left corner of the text.

drawText(txt, x, y, inverted):: Draw some text (inverted or not) at the given x and y position. +
                                *txt*: the text to draw. If a number or something else is given, it will be converted in text before drawing. +
                                *x*, *y*: the x coordinate of the top left corner of the text. +
                                *inverted*: if true, the text will be inverted, text will be normal otherwise.
                      
drawLine(x1, y1, x2, y2):: Draw a line between the given points. +
                           *x1*, *y1*: the 1st point coordinates. +
                           *x2*, *y2*: the 2nd point coordinates.

drawRectangle(x, y, width, height):: Draw a rectangle starting at the given point with the given width and height. +
                                     *x*, *y*: the top left corner of the rectangle. +
                                     *width*: the width of the rectangle. +
                                     *height*: the height of the rectangle (under the top left corner: The rectangle is draw to the bottom of the screen).

fillRectangle(x, y, width, height):: Fill a rectangle, see `drawRectangle` for parameters description.

drawCircle(x, y, radius):: Draw a circle with the given center and radius. +
                           *x*, *y*: the center of the circle. +
                           *radius*: the radius of the circle.

fillCircle(x, y, raduis):: Fill a circle, see `drawCircle` for parameters description.

drawArc(x, y, width, height, startAngle, arcAngle):: Draw an arc that is in the rectangle given by the point, the width and the height. The arc that at the startAngle and turn for arcAngle. +
                                                     *x*, *y*: the top left corner of the rectangle containing the arc. +
                                                     *width*: the width of the rectangle containing the arc. +
                                                     *height*: the height of the rectangle containing the arc. +
                                                     *startAngle*: the angle where we start to draw the arc. +
                                                     *arcAngle*: the angle of the arc draw. Example: 360 means that the full arc (elipse) will be drawn, 90 means that only a quarter of the arc will be drawn. 

fillArc(x, y, width, height, startAngle, arcAngle):: Fill an arc, see `drawArc` for parameters description.

getWidth():: Returns the width of the screen (should be 178).

getHeight():: Returns the height of the screen (should be 128).

getFontHeight():: Returns the height of the current font (O if no font selected).

drawImage(img, x, y):: Draw an image on the screen. +
                       *img*: the image to draw. +
                       *x*, *y*: the top left corner of the image.

decodeImage(data):: Decode an image from the image raw data. +
                    *data*: the image raw data. Currently the only way to generate these raw data is to use import an image with the Gnikrap "Import images" feature.

buildImage(line1, line2, ..., lineN):: Build an image from the given pixel lines. +
                                       Each characters on the lines represent a pixel on the image. Space are for white pixel, any other characters for a black pixel. All the lines should have the same number of characters(/pixel) +
                                       *line1*, ..., *lineN*: the pixels of the image.

****


Sample script with Screen object (drawing):
[source,javascript]
----
// Screen API
var screen = ev3.getBrick().getScreen();

screen.clear();

screen.drawText("Hello world !", 0, 0);

screen.drawLine(5, 20, 120, 20);

screen.drawRectangle(10, 30, 20, 30);
screen.fillRectangle(40, 30, 30, 20);

screen.drawCircle(90, 40, 15);
screen.fillCircle(130, 40, 15);

screen.drawArc(10, 70, 20, 30, 0, 180);
screen.fillArc(10, 70, 20, 30, 180, 180);

ev3.sleep(5000);
----


Sample script with Screen object (decode image):
[source,javascript]
----
// Screen API
// Decode an image from raw data (use Gnikrap 'import images' menu
var imgWorker02 = ev3.getBrick().getScreen().decodeImage("data:image/rgf;base64,sncAAAAAAAAAAAAAAAAAA" + 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAJAAAAAAAAAAAAAAAAAAAA" + 
"AAAAAAAACQACQAAAAAAAAAAAAAAAAAAAAAAAAAAAQggAAAAAAAAAAAAAAAAAAAAAAAAAECAAIAAAAAAAAAAAAAAAAAAAAAAAAAAE" + 
"BJABAQAAAAAAAAAAAAAAAAAAAAAAACAAAIAAQAAAAAAAAAAAAAAAAAAAAAAACSAABAIAAAAAAAAAAAAAAAAAAAAAAAAABIQASAAA" + 
"AAAAAAAAAAAAAAAAAAAAAAlAABAQgEAAAAAAAAAAAAAAAAAAAAAAAAAIRLQBwAAAAAAAAAAAAAAAAAAAABASSLQG8APAAAAAAAAA" + 
"AAAAAAAAAAAAAAAAPxf0hkAAAAAAAAAAAAAAAAAAAAAICWA/n/gIQAAAAAAAAAAAAAAAAAAAAAAgCQ/8OJIAAAAAAAAAAAAAAAAA" + 
"AAAAFAVgB/Q6YwBAAAAAAAAAAAAAAAAAAAA4P+vD4D/gAAAAAAAAAAAAAAAAAAAAADo//+HAP8EAwAAAAAAAAAAAAAAAAAAAPD//" + 
"wcA/xAHAAAAAAAAAAAAAAAAAAAAPKD/JwD+cwAAAAAAAAAAAAAAAAAAAADYBfoPIMZ5AQAAAAAAAAAAAAAAAAAAAP6T4AcElncAA" + 
"AAAAAAAAAAAAAAAAAAA7AKCBx8GwwAAAAAAAAAAAAAAAAAAAACWC6gfFZbmAAAAAAAAAAAAAAAAAAAAAJQigB8nB0cBAAAAAAAAA" + 
"AAAAAAAAAAAkIcEH20jnAMAAAAAAAAAAAAAAAAAAADSCyAfCgv6AAAAAAAAAAAAAAAAAAAAAPQnCX7EgfAAAAAAAAAAAAAAAAAAA" + 
"AAA4AtA/PkhSgAAAAAAAAAAAAAAAAAAAADqlwT5f4gQAAAAAAAAAAAAAAAAAAAAAMAPEOC/oKcBAAAAAAAAAAAAAAAAAAAAyi9BS" + 
"hVqDQAAAAAAAAAAAAAAAAAAAACAXwQAQKj6AwAAAAAAAAAAAAAAAAAAABQ/kZASelcFAAAAAAAAAAAAAAAAAAAAQH8EAoDWugcAA" + 
"AAAAAAAAAAAAAAAAAAI/pFIpLr1DgAAAAAAAAAAAAAAAAAAAKB8IwBAV68LAAAAAAAAAAAAAAAAAEAFCPmPVNX6+h8AAAAAAAAAA" + 
"AAAAAAAECgg8D+qqlX/BwAAAAAAAAAAAAAAAACkQkDFf+pV/38DAAAAAAAAAAAAAAAAAAiVEqi/Wquq6gEAAAAAAAAAAAAAAAAAU" + 
"SilAlrt3v9fAAAAAAAAAAAAAAAAAACEUgioJNpr7fYAAAAAAAAAAAAAAAAAgCilUgVJtf6/3wAAAAAAAAAAAAAAAAAAQUiVKBL6V" + 
"fX6AwAAAAAAAAAAAAAAAECqEipFpKS/r1cHAAAcAAAAAAAAAAAAAAClYKgSqWp1/QAAAD4AAAAAAAAAAABQVUhVBaWS/q+rAAAAP" + 
"gAAAAAAAAAAAACAErKqSCSp2t4AAAA/AAAAAAAAAAAAUFWkdFSVqqq/NQAAgD4AAAAAAAAAAAAAgAr5IqlUVWovAACA/gAAAAAAA" + 
"AAAAKgqUPJUUqWqKiAAAEA/AAAAAAAAAAAAAECF9EmVqqqqAAAAoP4AAAAAAAAAAABUFSjhl6qqqqoAAACgPgAAAAAAAAAAAACgQ" + 
"spfUFJV1QHgAFD/AAAAAAAAAAAAqgoUoP+KJKmqA/D/rz4AAAAAAAAAAAAAUEEF/ytJStUH8P+v/gAAAAAAAAAAAKoCFFD8X5JS9" + 
"S/4/1//AQAAAAAAAAAAAFRBBdD/r6r+T/T/r/4BAAAAAAAAAABVARRQov7///+f+v9f/wEAAAAAAAAAAABUQQII9f//8z/1/7/+A" + 
"AAAAAAAAACAqgAESELq///Af/z/V/8AAAAAAAAAAAAAKlECEND//wB/+f+//gAAAAAAAAAAgKoABJAAgf9/AGj6/9f/AAAAAAAAA" + 
"AAAAFIhAUQI/n8A0fz/3z8AAAAAAAAAAIBKAAQkAYD4fwAE+f/XfwAAAAAAAAAAAACVkAAQIfS/AFH6/+9fAAAAAAAAAACAKgACB" + 
"AQAwB8EhPz/+w8AAAAAAAAAAACAVEiQAACAnwAQ/f//DwAAAAAAAAAAgBIAAQEQABAGCED+//8HAAAAAAAAAAAAQCUkCAQAAAgCC" + 
"P3//w8AAAAAAAAAAIAKgABCAAAAQgBA/v//DwAAAAAAAAAAACAJkgAQAEAAABD8//8BAAAAAAAAAACACqAAiIQAAAAIAP3//wEAA" + 
"AAAAAAAAACgChIhACQAAABA+P//AAAAAAAAAAAAgAogAAAQAQIAAADw//8BAAAAAAAAAAAAIIlEhASAAAAQAOH//wAAAAAAAAAAA" + 
"IAKIAAAACQQAAAAxP8/AAAAAAAAAAAAQKAKCQAgAAAAAAAA/z8AAAAAAAAAAAAABSBABAgAAAAEAEjqDwAAAAAAAAAAAABQigQgA" + 
"gAgACAAAhQAAAAAAAAAAAAAAAIgEAEAAAAAAABAqQIAAAAAAAAAAAAAVIUEAAAAQCAAAAiSAAAAAAAAAAAAAAAAECCSRAAJBBEAQ" + 
"CQAAAAAAAAAAAAAAFRFCQAQEgAAAAAICQAAAAAAAAAAAAAAABBAAIBAIiAAACAAAAAAAAAAAAAAAACoQhKSBAgICRIAgAoAAAAAA" + 
"AAAAAAAAAAUAAAAAACAAAAoAAAAAAAAAAAAAAAAUEElCBCBECAgAIAKAAAAAAAAAAAAAAAICoAgAQiCBAIAEgAAAAAAAAAAAAAAA" + 
"EBQFQIkIiCASAFABQAAAAAAAAAAAAAAgAJAKICABAgAhAoAAAAAAAAAAAAAAAAAVBWBKiogIZEAoAAAAAAAAAAAAAAAAAABQCSAg" + 
"AQIBCoJAAAAAAAAAAAAAAAAgFQVgRQqkEAgAKAAAAAAAAAAAAAAAAAAACAUQIACEomkCgAAAAAAAAAAAAAAAACoSqESKUgAAAAgA" + 
"AAAAAAAAAAAAAAAAEgUCkSAAKVSVQUAAAAAAAAAAAAAAAAAgKJQERUqAAAACAAAAAAAAAAAAAAAAAAAFAVKoIAqlUoBAAAAAAAAA" + 
"AAAAAAAAACiqJAKKgAAEAIAAAAAAAAAAAAAAAAAAApFJVCAqqpCAAAAAAAAAAAAAAAAAAAAqChIhSoAAJQAAAAAAAAAAAAAAAAAA" + 
"AAARRUoQFVVIQAAAAAAAAAAAAAAAAAAAAAooEIVAAAKAAAAAAAAAAAAAAAAAAAAAEAVFKCqqgAAAAAAAAAAAAAAAAAAAAAAAKWiC" + 
"gARAAAAAAAAAAAAAAAAAAAAAAAAURVRVQIAAAAAAAAAAAAAAAAAAAAAAABwqEoiAgAAAAAAAAAAAAAAAAAAAAAAAAAIACAAAAAAA" + 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + 
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

ev3.getBrick().getScreen().drawImage(imgWorker02, 0, 0);
ev3.sleep(5000);
----


Sample script with Screen object (decode image):
[source,javascript]
----
// Screen API
// Build an image
var smiley = ev3.getBrick().getScreen().buildImage(
  "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X    XXXX             XXXX   X"
  "X     XX               XX    X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X    XX                XX    X"
  "X      XX            XX      X"
  "X        XXXXXXXXXXXX        X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "X                            X"
  "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX "
  );

ev3.getBrick().getScreen().drawImage(smiley, 40, 40);
ev3.sleep(5000);

----

// ///////////////////////////////////////////////////////////////////////////
=== The Battery object
// ///////////////////////////////////////////////////////////////////////////

****
getBatteryCurrent():: Returns current draw from the battery (in Amps).

getMotorCurrent():: Returns current draw by the motors (in Amps).

getVoltageMilliVolt():: Battery voltage in mV. ~9000 = full.
****


Sample script with Battery object:
[source,javascript]
----
// Battery API
var battery = ev3.getBrick().getBattery();
ev3.notify("Battery current: " + battery.getBatteryCurrent());
ev3.notify("Motor current: " + battery.getMotorCurrent());
ev3.notify("Voltage: " + battery.getVoltageMilliVolt());
----

// ///////////////////////////////////////////////////////////////////////////
=== The XSensor object
// ///////////////////////////////////////////////////////////////////////////

The XSensor enable you to use sensors of the device used to access to the EV3 brick. For example you can use
the gyroscope sensor of your tablet, or you can use the webcam of your laptop.

This has two main benefits:

* Have new sensors for free (you already have the tablet or the laptop !).
* Use these new sensors in your program as simply as if they were Lego sensors.


There is API common to all XSensors:

****
getName():: Returns the name of the XSensor.

getValue():: Returns the *current* value of the XSensor. It is *IMPORTANT* to note that two successive calls to `getValue()` can 
             return different value if the sensor has been modified meantime.
****


[TIP]
====
For all XSensor values there is function `isStarted()` that returns `true` if started or `false` if not. *If the XSensor
isn't started (i.e. `isStarted()` returns `false`), all the other methods on the value object could cause an error if they are called (and the program will be stopped).*
So after retrieving the value, it is important to check if `isStarted()` returns `true` before calling the other methods of the value object.
====


==== The xTouch XSensor

The aim of the xTouch sensor is to provide an easy to define a keyboard (24 touchs) that can be used in order to send "action" to the ev3.
In some sense, it can be seens as a 'super' beacon (see <<RemoteCommandResult object>>)


image::xsensor/xTouch_001_configure.png[xTouch, 640, 400]

In the screen, you can:

* Set the sensor name (in the screenshot: "joystick").
* xTouch not started: Configure the xTouch sensor, that is to say set the buttons 'actions names': Click on a button and set the list of actions (comma separated) for the button.
* xTouch started: While a button was clicked, the action was sent to the EV3 brick, while the button was no more clicked, the action is canceled. On multi-touch devices, you can click/touch several buttons at the same time.
+
Note: While started, the buttons not configured (without associated actions) will be disabled. 


Here are the fields available on the XTouch XSensor:

[NOTE]
====
Only the *active* touches are available within the XSensor values.
====

****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

containsTouch(name):: Returns `true` if the touch is available, that is to say active, `false` otherwise. +
                      *name*: the name of the touch to look for.

getTouch(name):: Returns a <<Touch object>> for the given touch. +
                 *name*: the name of the touch to look for.

getTouches():: Returns an array of all the <<Touch object>>s available.
****

===== Touch object

****
getName():: Returns the name of the touch.

getHits():: Returns the number of simultaneous hits for the touch (several touch can have the same name).
****


Sample script with xTouch XSensor:
[source,javascript]
----
// xTouch XSensor
// Configure the xTouch sensor with at least one touch "up"
var xTouch = ev3.getXSensor("xTouch");
while(ev3.isOk()) {
  var value = xTouch.getValue();
  if(value.isStarted()) {
    if(value.containsTouch("up")) {
      ev3.notify("You have clicked the 'up' touch !");
    } else {
      ev3.notify("Click on 'up'");
    }
  }
  
  ev3.sleep(100);
}
----


==== The xGyro XSensor

The aim of the xGyro sensor is to provide an access to the gyroscope sensor of a tablet or a smartphone. The EV3 brick can use in real-time the information for the x, y and z axis.

image::xsensor/xGyro_001_running.png[xGyro, 640, 400, align="center"]

In the screen, you can:

* Set the sensor name (in our example: "xGyro").
* Set the orientation of the device (portrait/left landscape/right landscape, reverse portrait) in order to have the 'right' values on each axis.
* Start the xGyro sensor.

[TIP]
====
In order to avoid annoying screen rotation, think to disabled the 'auto rotate' on your device while using the xGyro sensor.
====


****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

getX():: Returns an <<Axis object>>. The angle is between -90° and 90°. +
         X is the front-back tilt in degrees where front is positive (also known as 'beta' with 'Portrait' orientation).

getY():: Returns an <<Axis object>>. The angle is between -90° and 90°. +
         Y is the left-right tilt in degrees, where right is positive (also known as 'gamma' with 'Portrait' orientation)

getZ():: Returns an <<Axis object>>. The angle is between 0° (north) and 360° (Maybe not on all devices ?? Make some trials with your device). +
         The compass direction of the device in degrees (also known as 'alpha').  +
         _Note_: Some devices don't support compass (the z value will always be 0). For some devices, the compass don't returns the angle with the north.
****


===== Axis object

****
getAngle():: Returns the angle in degrees.
****

Sample script with xGyro XSensor:
[source,javascript]
----
// xGyro XSensor
var xGyro = ev3.getXSensor("xGyro");

while(ev3.isOk()) {
  var value = xGyro.getValue();
  if(value.isStarted()) {
    var y = value.getY().getAngle();
    var x = value.getX().getAngle();
    
    ev3.notify("XGyro - x: " + x + ", y: " + y);
  }
  
  ev3.sleep(100);
}
----


==== The xVideo XSensor

The aim of the xVideo sensor is to provide an access to the webcam of a laptop or a tablet. You can indicate one or several object that are tracked. The EV3 brick can use in real-time the position of all the tracked objects.


image::xsensor/xVideo_001_running.png[xVideo, 640, 400, align="center"]

In the screen, you can:

* Start the xVideo sensor. While starting the browser will certainly ask you to select the webcam to use (and to give the authorization to
  use this webcam).
* Select objects to track: Click on the video to select the objects to track. You can give the name you want to the object.
  You can also change the name by clicking again on the object.

[TIP]
====
.There is several important point to note about the tracking algorithm used:
- Under 20 FPS (frame per seconds), the object will be often loosed (_The number of FPS is displayed above the video_). +
  The FPS will vary according to the browser and the energy-saving policy of the device (in all cases, a maximum seems to be 60 FPS).
- Tracking objects with an important black/white contrast is the best option (i.e. objects with with and black surface that are visible from the camera).
  On the opposite, tracking object with uniform colour don't work very well. +
  Here are two sample of '"targets"' that works quite fine: image:xsensor/xVideo_pattern_001.png[Pattern001, 60, 60] and image:xsensor/xVideo_pattern_002.png[Pattern002, 60, 60].
  
  
- If there is something (even for a very short time) between the camera and the tracked object, the object will be loosed.
- You can move the camera (not too quickly) without any problem.
- Your object can move/rotate/etc. without any problem.


Note: The algorithm used was the Lucas-Kanade method (See http://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method[wikipedia] for more details).
====


****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

containsObject(name):: Returns `true` if the object is available, that is to say tracked, `false` otherwise. +
                      *name*: the name of the object to look for.

getObject(name):: Returns a <<VisibleObject object>> for the given object. +
                 *name*: the name of the object to look for.

getObjects():: Returns an array of all the <<VisibleObject object>>s available.
****

===== VisibleObject object

****
getName():: Returns the name of the object.

getX():: Returns the x value for this object (x goes from 0 to 640).

getY():: Returns the y value for this object (y goes from 0 to 480).
****

Sample script with xVideo XSensor:
[source,javascript]
----
// xVideo XSensor
// Configure the xVideo sensor to track one object called "myTarget"
var xVideo = ev3.getXSensor("xVideo");
while(ev3.isOk()) {
  var value = xVideo.getValue();
  if(value.isStarted()) {
    if(value.containsObject("myTarget")) {
      var t = value.getObject("myTarget");
      ev3.notify("Target found: [" + t.getX() + ", " + t.getY() + "]");
    } else {
      ev3.notify("Hey, select a target and call it 'myTarget'");
    }
  }
  
  ev3.sleep(100);
}
----


==== The xGeo XSensor

The aim of the xGeo sensor is to provide an access to the GPX sensor of a tablet or a smartphone. The EV3 brick can use in real-time the information for the latitude, longitude and altitude.

image::xsensor/xGeo_001_running.png[xGeo, 640, 400, align="center"]

In the screen, you can:

* Set the sensor name (in our example: "xGeo").
* Start the xGeo sensor.


****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

getTimestamp():: Returns the timestamp where the GPS coordinate has been acquired.

getLatitude():: Returns the latitude.

getLongitude():: Returns the longitude.

getAccuracy():: Returns the accuracy (in meter) of the latitude and longitude.

getAltitude():: Returns the altitude (in meter). +
                _Note_: Some devices don't support altitude (the value will always be 0).
                
getAltitudeAccuracy():: Returns the accuracy (in meter) of the altitude. +
                        _Note_: Some devices don't support altitude (the value will always be 0).
****


Sample script with xGeo XSensor:
[source,javascript]
----
TODO
----


[NOTE]
====
The GPS coordinate are currently requested to be acquired every 30 seconds. +
_Note:_ This parameter could be make configurable in a future version of Gnikrap.
====


==== Advanced usage

You can use several xSensor at the same time. Theses sensors can be on the same device or on several devices.
For example, you can run on the same device the xGyro sensor and the xTouch sensor. Another example could be 
to run the xGyro sensor on one device and the xVideo sensor on another device.

[IMPORTANT]
====
.However it is recommended to limit to:
- 4 active XSensor at the same time _(especially for xGyro and xVideo sensor that always send new values to the EV3 brick. 
  Sending the values of more than 4 sensors at the same time can flood the EV3 brick)_.
- 2 devices connected to the EV3 at the same time _(The network bandwidth available on
  the EV3 brick is quite limited, especially with bluetooth, so 2 is ok, more can be challenging).

====


A note on the behaviour of the function `ev3.isOk()` while using XSensors: Even if not configured (see <<Configuration object>>)
this method will automatically wait a bit while one or several XSensors are actively sending data to the brick. This waiting time
will be automatically reset while there is no more active XSensors. +
_Note_: The aim of this small waiting time is to let the EV3 CPU process the XSensors incoming values in a proper way.
