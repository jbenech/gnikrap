{  "@comment": "Traduction française",  "navigationBar": {    "run": "Démarre",    "stop": "Arrête",    "gnikrap": {      "about": "A propos...",      "fullScreen": "Basculer en mode plein écran",      "stopGnikrap": "Arrêter Gnikrap...",      "settings": "Configuration...",      "importImages": "Importer des images...",      "documentation": "Documentation..."    },    "confirmStopGnikrap": {      "title": "Arrêter Gnikrap",      "message": "Voulez vous arreter de Gnikrap (la brique va revenir sur le menu), ou arrêter la brique ?",      "cancel": "Non, ne rien faire",      "stopGnikrap": "Oui, arrêter Gnikrap",      "shutdownBrick": "Oui, arrêter la brique"    }  },  "workArea": {    "@comment": "La liste des 'zone des travail' disponibles",    "scriptEditorTab": "Editeur de script",    "keyboardSensorTab": "xClavier",    "videoSensorTab": "xVidéo",    "gyroSensorTab": "xGyroscope",    "geoSensorTab": "xGéo"  },  "messageLog": {    "clear": "Effacer",    "keepLast": "Ne garder que les derniers messages"  },  "scriptEditorTab": {    "clear": "Nouveau",    "loadAndManage": "Charger/Gérer",    "save": "Sauver",    "loadingScripWait": "// Chargement du script: '__filename__'...",    "scriptSuccessfullySaved": "Le script '__filename__' a été sauvegardé avec succès",    "demo": {      "no_load": "Mode démo, impossible de charger un programme",      "no_save": "Mode démo, impossible de sauver un programme"    },    "errors": {      "cantLoadScriptFile": "Impossible de charger le script '__filename__'. [__causedBy__]",      "cantSaveScriptFile": "Impossible de sauvegarder le script '__filename__'. [__causedBy__]"    },    "saveScriptModal": {      "title": "Sauver le script avec le nom suivant:"    },    "clearScriptModal": {      "title": "Etes vous sûr de vouloir créer un nouveau script (le script actuel ne sera plus affiché) ?"    }  },  "keyboardSensorTab": {    "sensorName": "Nom",    "start": "Démarrer",    "clear": "Nouveau",    "loadAndManage": "Charger/Gérer",    "save": "Sauver",    "configureKeyboardButtonModal": {      "title": "Entrer le(s) nom(s) du bouton (utiliser la virgule pour séparer plusieurs noms)"    },    "resetKeyboardModal": {      "title": "Etes vous sûr de vouloir remettre à zéro la configuration du xClavier ?"    }  },  "gyroSensorTab": {    "start": "Démarrer",    "setAxis": "Orientation de l'appareil",    "xAxis": "x est le tilt avant-arrière en degrés, les valeurs positivies sont vers l'avant (aussi connu sous le nom 'beta' en mode 'Portrait')",    "yAxis": "y est le tilt gauche-droite en degrés, les valeurs positives sont vers la droite (aussi connu sous le nom 'gamma' en mode 'Portrait')",    "zAxis": "z est la 'boussole' de l'appareil (aussi connu sous le nom 'alpha')",    "zAxisNote": "Note: Pour les appareils ne supportant pas la 'boussole' la valeur sera toujours 0. Sur certains appareils l'angle retourné par la boussole n'est pas pas l'angle avec le nord.",    "axisOrientation": {      "o0": "Portrait",      "o90": "Paysage à gauche",      "o-90": "Paysage à droite",      "o180": "Portrait inversé"    },    "setAxisDialogLight": {      "title": "Changer l'orientation de l'appareil",      "message": "L'orientation détectée est : '__axisOrientation__'",      "cancel": "Annuler",      "ok": "Accepter",      "fullChoice": "Autres orientations..."    },    "setAxisDialogFull": {      "title": "Changer l'orientation de l'appareil",      "message": "Choisir l'orientation de l'appareil pour avoir les valeurs attendues. L'orientation par défaut est 'Portrait', en général c'est quand le cordon d'alimentation de l'appareil est vers le bas.",      "cancel": "Annuler",      "landscapeLeft": "Paysage à gauche",      "landscapeRight": "Paysage à droite",      "portrait": "Portrait",      "reversePortrait": "Portrait inversé"    }  },  "videoSensorTab": {    "start": "Démarrer",    "addPoints": "Cliquer sur la video pour ajouter des objets à suivre",    "newPoint": "Objet-",    "pointsNoMoreTracked": "L'objet '__name__' a été perdu, il ne sera plus suivi",    "errors": {      "maximumTrackedPointsReached": "Le nombre maximum (__number__) d'objets à surveiller a été atteint",      "videoAccessRefused": "Un erreur c'est produite lors de l'accés à la caméra"    },    "configureTrackedPointNameModal": {      "title": "Entrer le nom de l'objet à surveiller"    }  },  "geoSensorTab": {    "start": "Démarrer",    "latitude": "La latitude (ou parallèle) est une position nord-sud sur la surface la terre (0° à l'équateur, +90° au pôle nord, -90° au pôle sud).",    "longitude": "La longitude est une position est-ouest sur la surface de la terre (0° sur le méridien de Greenwich).",    "accuracy": "La précision (en mètre) de la latitude et de la longitude.",    "altitude": "L'altitude en mètre par rapport au niveau de la mer (Pour les appareils ne supportant pas l'altitude la valeur sera toujours 0).",    "altitudeAccuracy": "La précision (en mètre) de l'altitude (Pour les appareils ne supportant pas l'altitude la valeur sera toujours 0).",    "timestamp": "La date et heure à laquelle la géolocalisation a eu lieu.",    "errors": {      "timeout": "La géolocalisation est trop lente (__detail__)",      "permissionDenied": "Vous devez accepter la géolocalistaion pour faire fonctionner le capteur xGéo (__detail__)",      "positionUnavailable": "Erreur interne durant la géolocalisation (__detail__)",      "unknownError": "Error lors de l'utilisation de la géolocalisation (__detail__)"    }  },  "manageScriptFilesModal": {    "title": "Gérer les scripts",    "c1": {      "title": "Nom du script"    },    "c2": {      "title": "Langage"    },    "load": "Charger",    "delete": "Supprimer",    "close": "Fermer",    "confirmScriptFileDeletion": "Voulez vous vraiment supprimer le script '__filename__' ?",    "errors": {      "cantRetrieveListOfScriptFiles": "Impossible de charger la liste des scripts. [__causedBy__]",      "cantDeleteScriptFile": "Impossible de supprimer le script '__filename__'. [__causedBy__]"    }  },  "importImagesModal": {    "title": "Importer des images",    "selectImage": "Sélectionnez une image a utiliser sur l'EV3:",    "useDithering": "Utiliser le tramage ?",    "keepAspectRatio": "Conserver les proportions ?",    "whiteBlackthreshold": "Seuil blanc / noir",    "selectCodeAndCopy": "Pour utiliser l'image, selectionnez le code suivant et copiez le:",    "close": "Fermer",    "errors": {      "fileIsNotAnImageSelectAnother": "'__filename__' ne peut être lu comme une image, sélectionnez un fichier d'image valide"    }  },  "ev3brick": {    "ev3ConnectionOk": "La connexion avec la brique EV3 est ok",    "confirmStopScriptAlreadyRunning": "Un script est déjà en cours d'exécution, faut-il l'arrêter avant de lancer le nouveau script ?",    "demo": {      "no_connection_to_EV3": "Mode démo, certaines fonctionnalités ne vont pas être disponibles car Gnikrap n'a pas été lancé sur une brique EV3",      "no_run": "Mode démo, impossible de démarrer le programme",      "no_stop_nor_shutdown": "Mode démo, rien ne va être arrêté"    },    "errors": {      "webSocketNotSupported": "Les 'WebSocket' ne sont pas supportées par votre navigateur. Veuillez utiliser une version plus récente de votre navigateur. Si ce n'est pas possible envisagez d'utiliser une version récente de Firefox.",      "ev3ConnectionFailed": "La connexion avec la brique EV3 à échouée. Nouvelle tentative de connexion dans quelques secondes. [__causedBy__]",      "ev3ConnectionNok": "La connexion avec la brique EV3 a été perdue. Nouvelle tentative de connexion dans quelques secondes.",      "cantRunScriptEV3ConnectionNok": "Impossible d'éxécuter le script, il n'y a pas de connexion avec la brique EV3.",      "cantStopScriptEV3ConnectionNok": "Impossible d'arrêter le script, il n'y a pas de connexion avec la brique EV3.",      "cantDoSomethingEV3ConnectionNok": "Impossible de faire: '__action__', il n'y a pas de connexion avec la brique EV3."    }  },  "settingsModal": {    "title": "Configuration",    "language": "Langue",    "programmingStyle": "Style de programmation",    "programmingStyleText": "Textuel (JavaScript)",    "programmingStyleVisual": "Visuel (EV3 blocks)",    "save": "Sauver",    "cancel": "Annuler"  },  "server": {    "@comment": "Traduction pour les messages qui viennent de la partie serveur/brique",    "errors": {      "INVALID_SENSOR_PORT": "Le port '__port__' n'est pas valide pour un capteur. La valeur doit être dans [S1, S2, S3, S4] ou [1, 2, 3, 4]",      "INVALID_MOTOR_PORT": "Le port '__port__' n'est pas valide pour un moteur. La valeur doit être dans [A, B, C, D]",      "API_NOT_IMPLEMENTED": "La fonction '__function__' n'est pas implémenté",      "INVALID_CHANNEL_VALUE": "Le channel '__channel__' n'est pas valide. La valeur doit être dans [1, 2, 3, 4]",      "INVALID_NOTE": "La note '__note__' n'est pas valide. La valeur doit être dans [C1-B7, # autorisé sur C, D, F, G, A] ou [Do-Si, # autorisé sur Do, Re, Fa, Sol, La]",      "UNEXPECTED_ERROR": "Erreur: '__error__'",      "SCRIPT_STOP_FORCED": "L'arrêt du script a été forcé. Veuillez utiliser \"ev3.isOk()\"",      "CANT_READ_FILE": "Erreur lors de la lecture du fichier '__filename__', l'erreur technique est: __error__",      "IMAGE_CORRUPTED": "L'image '__filename__' est corrompue (taille de fichier invalide)",      "BAD_IMAGE_DATA": "Les données fournies pour construire l'image ne sont pas correctes (essayez de vérifier que toutes les lignes ont la même longueur)",      "CANT_DECODE_IMAGE_INVALID_DATA_SIZE": "Il n'y a pas assez de données pour décoder une image de la taille suivante: [__width__, __height__]",      "CANT_DECODE_IMAGE": "Les données fournies ne sont pas correctes pour une image, raison: '__reason__'",      "CANT_DECODE_IMAGE_INVALID_TYPE": "Le type d'image fournie est inconnu: __type__"    },    "messages": {      "SCRIPT_STARTING": "Le script démarre",      "SCRIPT_ENDED": "Le script s'est arrêté"    }  },  "aboutModal": {    "gnikrapShortDescription": "<a href=\"http://jbenech.github.io/gnikrap/\" target=\"_blank\">Gnikrap</a> est un environment de programation javascript simple à utiliser et puissant pour <a href=\"http://www.lego.com/mindstorms/\" target=\"_blank\">Lego Mindstrom EV3</a>.",    "softwareUsed": "Ce logiel n'aurai pas vu le jour sans les logiciel open-source suivant:",    "gnikrapLicence": "Licence (Texte complet de la licence <a href=\"licence-lgpl-3.0.txt\" target=\"_blank\">GPL v3</a>):",    "gplV3Notice": [      "Gnikrap est un environment de programation javascript simple à utiliser",      "et puissant pour Lego Mindstorm EV3",      "Copyright (C) 2014-2015 Jean BENECH — Tous droits réservés.",      "",      "Ce programme est un logiciel libre ; vous pouvez le redistribuer ou le",      "modifier suivant les termes de la “GNU General Public License” telle que",      "publiée par la Free Software Foundation : soit la version 3 de cette",      "licence, soit (à votre gré) toute version ultérieure.",      "",      "Ce programme est distribué dans l’espoir qu’il vous sera utile, mais SANS",      "AUCUNE GARANTIE : sans même la garantie implicite de COMMERCIALISABILITÉ",      "ni d’ADÉQUATION À UN OBJECTIF PARTICULIER. Consultez la Licence Générale",      "Publique GNU pour plus de détails.",      "",      "Vous devriez avoir reçu une copie de la Licence Générale Publique GNU avec",      "ce programme ; si ce n’est pas le cas, consultez :",      "<a href=\"http://www.gnu.org/licenses/\" target=\"_blank\">http://www.gnu.org/licenses/</a>."    ],    "close": "Fermer"  },    "blocks": {    "@comment": "Translation for blockly'blocks defined for Gnikrap",    "categories": {      "logic": "Logique",      "loops": "Boucles",      "math": "Math",      "text": "Texte",      "lists": "Listes",      "ev3_brick": "Brique EV3",      "sensors": "Capteurs",      "color_sensor": "Cap. de couleur",      "ir_sensor": "Cap. infrarouge",      "touch_sensor": "Cap. de contact",      "keyboard": "Clavier",      "xSensors": "xCapteurs",      "motors": "Moteurs",      "variables": "Variables",      "functions": "Fonctions"    },        "errors": {      "blockTwoDifferentSensorsOnTheSamePort": "Deux capteurs de type différents utilisent le même port.",      "blockTwoDifferentMotorsOnTheSamePort": "Deux moteurs de type différents utilisent le même port.",      "blockNeedToDefineMotorType": "Le type du moteur n'est pas défini pour ce port.",      "blockXSensorValue": "Tous les blocks xSensors doivent être inclus dans un bloc 'avec le xSensor ... démarré faire'.",            "compilePortWithSeveralMotorType": "ERREUR: Plusieurs types de moteurs sont définis pourt le port __port__ !",      "compileMotorTypeNotDefineFor": "AVERTISSEMENT: Le type de moteur n'est pas défini pour le port __port__. Le type du moteur par défaut ('LargeMotor') sera utilisé pour ce port.",      "compilePortUsedForSeveralSensor": "ERREUR: Le port __port__ est utilisé pour plusieurs types de capteurs !",      "compileXSensorMustBeInsideWithxSensorDo": "ERREUR: Tous les blocks xSensors doivent être inclus dans un bloc 'avec le xSensor ... démarré faire' !"    },    "list_time_unit": {      "S": "secondes",      "MS": "millisecondes"    },    "list_speed_unit": {      "DEGREE_PER_S": "degré(s)/seconde",      "TURN_PER_S": "tour(s)/seconde",      "PERCENT": "% puissance"    },    "gnikrap_ev3_notify": {      "tooltip": "Affiche un message dans l'interface de Gnikrap.",      "text_notify": "notifier"    },    "gnikrap_ev3_isok": {      "tooltip": "Retoune vrai si la brique EV3 est ok, faux sinon.",      "text_ev3_is_ok": "EV3 est ok"    },    "gnikrap_ev3_stop": {      "tooltip": "Arrête le programme.",      "text_stop_script": "arrêter le programme"    },    "gnikrap_ev3_wait_until": {      "tooltip": "Attend jusqu'à ce que la condition soit vrai.",      "text_wait_until": "attendre jusqu'à ce que"    },    "gnikrap_ev3_sleep": {      "tooltip": "Le programme va attendre (ne rien faire) pendant le temps indiqué.",      "text_sleep": "attendre pendant"    },    "gnikrap_ev3_led": {      "tooltip": "Met le LED dans l'état sélectionné.",      "list_change_LED_status": {        "OFF": "mettre le LED à éteint",        "GREEN": "mettre le LED à vert",        "GREEN_1": "mettre le LED à vert clignotant",        "GREEN_2": "mettre le LED à vert clignotant rapide",        "ORANGE": "mettre le LED à orange",        "ORANGE_1": "mettre le LED à orange clignotant",        "ORANGE_2": "mettre le LED à orange clignotant rapide",        "RED": "mettre le LED à rouge",        "RED_1": "mettre le LED à rouge clignotant",        "RED_2": "mettre le LED à rouge clignotant rapide"      }    },    "gnikrap_ev3_sound_setvolume": {      "tooltip": "Règle le volume sonore.",      "text_set_volume": "régler le volume sonore à"    },    "gnikrap_ev3_sound_beep": {      "tooltip": "Joue un bip.",      "text_beep": "jouer un bip"    },    "gnikrap_ev3_sound_playnote": {      "tooltip": "Joue la note indiqué pendant le temps indiqué.",      "text_play_note": "jouer la note",      "text_for": "pendant"    },    "gnikrap_ev3_touchsensor_pushed": {      "tooltip": "Retourne vrai si le capteur est enfoncé, faux sinon.",      "text_sensor": "le capteur",      "text_is_pushed": "est enfoncé"    },    "gnikrap_ev3_colorsensor_reflected": {      "tooltip": "Retourne la lumière réfléchie (entre 0 et 100) détecté par le capteur.",      "text_reflected_light": "la lumière réfléchie du capteur"    },    "gnikrap_ev3_colorsensor_ambient": {      "tooltip": "Retourne la lumière ambiante (entre 0 et 100) détecté par le capteur.",      "text_ambiant_light": "la lumière ambiante du capteur"    },    "gnikrap_ev3_colorsensor_getcolor": {      "tooltip": "Retourne la couleur (texte en anglais) détecté par le capteur.",      "text_color": "la couleur du capteur"    },    "gnikrap_ev3_colorsensor_iscolor": {      "tooltip": "Retoune vrai si la couleur sélectionnée est celle détécté par le capteur, faux sinon.",      "list_colors_detected": {        "BLACK": "noir est détecté par le capteur",        "BLUE": "bleu est détecté par le capteur",        "YELLOW": "jaune est détecté par le capteur",        "RED": "rouge est détecté par le capteur",        "WHITE": "blanc est détecté par le capteur",        "BROWN": "marron est détecté par le capteur",        "NONE": "aucune couleur n'est détecté par le capteur"      }    },    "gnikrap_ev3_irsensor_setchannel": {      "tooltip": "Règle le canal à utiliser pour le capteur infrarouge.",      "text_set_channel": "régler le canal à",      "text_to_sensor": "pour le capteur infrarouge"    },    "gnikrap_ev3_irsensor_getdistance": {      "tooltip": "Retourne la distance (entre 0 et 100) au capteur infrarouge.",      "text_distance_to_sensor": "distance au capteur infrarouge"    },    "gnikrap_ev3_irsensor_getremotecommand": {      "tooltip": "Retourne vrai si le bouton sélectionné est préssé sur la télécommande, faux sinon.",      "list_beacon_buttons_enabled_on_sensor": {        "TOP_LEFT": "le bouton en haut à gauche est enfoncé sur le capteur infrarouge",        "TOP_RIGHT": "le bouton en haut à droite est enfoncé sur le capteur infrarouge",        "BOTTOM_LEFT": "le bouton en bas à gauche est enfoncé sur le capteur infrarouge",        "BOTTOM_RIGHT": "le bouton en bas à droite est enfoncé sur le capteur infrarouge",        "BEACON": "le bouton 'beacon' est enfoncé sur le capteur infrarouge",        "NOTHING": "rien n'est enfoncé sur le capteur infrarouge"      }    },    "gnikrap_ev3_keyboard_wait": {      "tooltip": "Attends que le bouton soit enfoncé (et relanché si sélectionné).",      "list_keyboard_buttons_wait": {        "UP": "attendre que le bouton haut",        "DOWN": "attendre que le bouton bas",        "LEFT": "attendre que le bouton gauche",        "RIGHT": "attendre que le bouton droite",        "ENTER": "attendre que le bouton entrer",        "ESCAPE": "attendre que le bouton annuler"      },      "list_keyboard_buttons_actions": {        "PRESSED": "soit enfoncé",        "PRESSED_AND_RELEASED": "soit enfoncé et relaché"      }    },    "gnikrap_ev3_keyboard_ispressed": {      "tooltip": "Retourne vrai si le bouton est enfoncé, faux sinon.",      "list_keyboard_buttons_is_pressed": {        "UP": "le bouton haut est enfoncé",        "DOWN": "le bouton bas est enfoncé",        "LEFT": "le bouton gauche est enfoncé",        "RIGHT": "le bouton droite est enfoncé",        "ENTER": "le bouton entrer est enfoncé",        "ESCAPE": "le bouton annuler est enfoncé"      }          },    "gnikrap_ev3_motor_settype": {      "tooltip": "Règle le type de moteur connecté sur le port sélectionné.",      "list_motor_type_connected_on": {        "LARGE": "un gros moteur est connecté sur le port",        "MEDIUM": "un moteur moyen est connecté sur le port"      }    },    "gnikrap_ev3_motor_move": {      "tooltip": "TODO",      "list_motor_actions": {        "FORWARD": "tourner en avant le moteur",        "BACKWARD": "tourner en arrière le moteur",        "STOP_LOCK": "arrêter et vérouiller le moteur",        "STOP": "arrêter le moteur"      }    },    "gnikrap_ev3_motor_ismoving": {      "tooltip": "Retourne vrai si le moteur est en train de tourner, faux sinon.",      "text_motor": "le moteur",      "text_is_moving": "est en train de tourner"    },    "gnikrap_ev3_motor_rotate": {      "tooltip": "TODO",      "list_motor_actions": {        "ROTATE": "faire tourner le moteur",        "ROTATE_NO_WAIT": "commencer à faire tourner le moteur"      },      "text_for": "de",      "list_angle_unit": {        "DEGREE": "degré(s)",        "TURN": "tour(s)"      }    },    "gnikrap_ev3_motor_setspeed": {      "tooltip": "Règle la vitesse du moteur.",      "text_set_speed_of_motor": "régler la vitesse du moteur",      "text_to": "à"    },    "gnikrap_ev3_motor_getspeed": {      "tooltip": "Retourne la vitesse du moteur.",      "text_speed_of_motor": "la vitesse du moteur",      "text_in": "en"    },    "gnikrap_ev3_motor_gettacho": {      "tooltip": "Retourne le nombre de pas du moteur depuis la dernière raz du nombre des pas.",      "text_tacho_count_of_motor": "nombre de pas du moteur"    },    "gnikrap_ev3_motor_resettacho": {      "tooltip": "Remet le nombre de pas du moteur à 0.",      "text_reset_tacho_count_of_motor": "remettre à zéro le nombre de pas du moteur"    },        "gnikrap_ev3_xsensor_workwith": {      "tooltip": "Si le xSensor existe et est démarré execute le bloc d'ordre 'faire'. Sinon le bloc d'ordre optionnel 'sinon' est executé.",      "text_with_the_xSensor": "avec le xSensor",      "text_started": "démarré",      "text_do": "faire",      "text_else": "sinon"    },        "gnikrap_ev3_xgyro_getvalue": {      "tooltip": "Retoune l'angle du capteur xGyro pour l'axe sélectionné.",      "list_axis_angle": {        "X": "xGyro: angle pour l'axe x",        "Y": "xGyro: angle pour l'axe y",        "Z": "xGyro: angle pour l'axe z"      }        },        "gnikrap_ev3_xgeo_getvalue": {      "tooltip": "Retoune la valeur du capteur xGéo pour la mesure sélectionnée.",      "list_measure": {        "LATITUDE": "xGéo: latitude",        "LONGITUDE": "xGéo: longitude",         "ACCURACY": "xGéo: précision",         "ALTITUDE": "xGéo: altitude",        "ALTITUDE_ACCURACY": "xGéo: précision de l'altitude",        "TIMESTAMP": "xGéo: date et heure"      }        },        "gnikrap_ev3_xvideo_containsobject": {      "tooltip": "Retourne vrai si l'objet indiqué est suivi par le capteur xVideo, faux sinon.",      "text_xVideo_known_the_object": "xVideo: connait l'objet"    },        "gnikrap_ev3_xvideo_getvalue": {      "tooltip": "Retourne pour l'objet indiqué la valeur pour la coordonée sélectionnée.",      "list_axis_for_object": {        "X": "xVidéo: coordonnée x pour l'objet",        "Y": "xVidéo: coordonnée y pour l'objet"      }        },        "gnikrap_ev3_xtouch_istouchpressed": {      "tooltip": "Retoune vrai si la touche indiquée est pressée, faux sinon.",      "text_xTouch_touch": "xTouch: la touche",      "text_is_pressed": "est pressée"    }      }}